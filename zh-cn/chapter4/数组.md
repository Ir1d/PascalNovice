#数组

为了给10个数从小到大排序，我们可以写出以下程序：

```delphi
//程序4_3_1_sort_fool
var q, w, e, r, t, y, u, i, o, p :longint;
var j, k :longint;
begin
	read(q, w, e, r, t, y, u, i, o, p);
	for j := 1 to 10 do begin //重复10次
		if q > w then begin
			k := q;
			q := w;
			w := k;
		end;//如果q>w则将它们两个交换
		if w > e then begin
			k := w;
			w := e;
			e := k;
		end; //如果w>e则将它们两个交换
		...
		if o>p then begin
			k := o;
			o := p;
			p := k;
		end; //如果o>p则将它们两个交换
	end;
	writeln(q, '', w, '',e, '',r, '',t, '',y, '',u, '',i, '',o, '',p);
end.
```

首先，这样排序的正确性是没有问题的（请试着证明），但是这样太麻烦了。

我们需要一种能够同时存储10个数的结构，并且能够套用循环。

下面给出数组的定义方法：

```
array[<下标起始值>..<下标终止值>] of <数据类型>
```

这样就产生了一种数据类型。例如，定义一个数组a，从下标从1到10，存储longint类型的数据，则：

```delphi
//程序4_3_2_array
var a:array[-1..10] of longint;
begin
	a[1] := 10000; //可以
	a[10] := 1000; //可以
	a[0] := 9; //不可，因为0不在1..10的范围当中
	a[2] := ''; //不可，''不是longint类型
end.
```

除了可以用整数（也就是说，负数也可以）作为下标外，用char类型也可以作为下标，例如：

```delphi
var a :array['a'..'z'] of longint;
```

对下标的引用不一定是常量。

例如：读入n（≤100）和n个数，然后将它们反序输出：

```delphi
//程序1_3_3_3_backwards
var n, i :longint;
var a :array[1..100] of longint;
begin
	read(n);
	for i := 1 to n do read(a[i]);
	for i := n downto 1 do writeln(a[i]);
end.
```

其实这个题可以不用显式地定义数组，可以利用递归的特性来解决～递归后边会提到咯

有的时候，我们需要储存的不是数的序列，而是数的矩阵，这时我们需要用到二维数组：

```
array[<下标起始值1>..<下标终止值1>, <下标起始值2>..<下标终止值2>] of <数据类型>
```

注意是二维数组不是二堆数组～

这得到一个数据类型，例如，如果定义：

```delphi
var a :array[-1..2, -2..1] of longint;
```

就会开辟出以下16个存储空间：
```
a[-1, -2]
a[-1, -1]
a[-1, 0]
a[-1, 1]
a[0, -2]
a[0, -1]
a[0, 0]
a[0, 1]
a[1, -2]
a[1, -1]
a[1, 0]
a[1, 1]
a[2, -2]
a[2, -1]
a[2, 0]
a[2, 1]
```
其中a[-1, -2]也可以写作a[-1][-2]，其余同理，这是因为：

```
array[<下标起始值1>..<下标终止值1>, <下标起始值2>..<下标终止值2>] of <数据类型>
```

相当于

```
array[<下标起始值1>..<下标终止值1>] of array[<下标起始值2>..<下标终止值2>] of <数据类型>
```

当然，也可以添加更多的逗号，建立更高维度的数组，这里不再赘述。

现在，作为思考题，请自己完成“读入N个数并将其排序”的题目。要求N≤1000时程序能在输入最后一个数以后1秒以内算出结果。（更高的要求是N≤50000）

---------

gl & hf;

开始新的OI征程吧～
