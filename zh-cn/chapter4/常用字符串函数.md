#常用字符串函数

>* copy

```
copy(<字符串表达式>, <整数表达式1>, <整数表达式2>)
```

copy得到一个值，是<字符串表达式>从第<整数表达式1>位开始算起，截取长度为<整数表达式2>的字符串。例如：

```delphi
//程序4_2_1_copy
var a :string;
begin
	a := copy('0123456789', 2, 4);
	writeln(a);
	//输出的是：1234
end.
```

如果<字符串表达式>的第<整数表达式1>位后不足<整数表达式2>位，则取到字符串的末尾。

>* delete

```
delete(<字符串变量名>, <整数表达式1>, <整数表达式2>);
```

delete将<字符串变量名>的第<整数表达式1>位开始的<整数表达式2>位删除。例如：

```delphi
//程序4_2_2_delete
var a :string;
begin
	a := '0123456789';
	delete(a, 2, 4);
	writeln(a);
	//输出的是：056789
end.
```

如果<字符串变量名>的第<整数表达式1>位后不足<整数表达式2>位，则将其之后的全部删除。

>* insert

```
insert(<字符串表达式>, <字符串变量名>, <整数表达式>);
```
insert将<字符串表达式>插入到<字符串变量名>的第<整数表达式>位中。例如：

```delphi
//程序4_2_3_insert
var a :string;
begin
	a := '056789';
	insert('1234', a, 2);
	writeln(a);
	//输出的是：0123456789
end.
```

>* length

```
length(<字符串表达式>)
```
length得到一个值，是<字符串表达式>的长度。例如：

```delphi
//程序4_2_4_length
begin
	writeln(length('0123456789'));
	//输出的是：10
end.
```

>* pos

```
pos(<字符串表达式1>, <字符串表达式2>)
```

pos得到一个值：如果<字符串表达式1>被完全包含于<字符串表达式2>中，则得到<字符串表达式1>第一次出现的位置，否则得到0。例如：

```delphi
//程序4_2_5_pos
begin
	writeln(pos('1234', '01234123456789'));
	//输出的是：2
	writeln(pos('1234', '01231423456789'));
	//输出的是：0
end.
```

>* str

```
str(<整数或实数表达式>, <字符串变量名>);
```

str将<整数或实数表达式>转化为字符串存储在<字符串变量名>中。如果是实数，依然可以用“ :0 :x”来保留x位小数。例如：

```delphi
//程序4_2_6_pos
var a, b :string;
begin
	str(2.33333 :0 :2, a);
	str(456, b);
	writeln(a + b);
	//输出的是：2.33456
end.
```

>* val

```
val(<字符串表达式>, <整数或实数变量名>, <整数变量名>);
```

val试图将字符串表达式转化为一个数：如果成功，会将这个数存放在<整数或实数变量名>中，并且令<整数变量名>为0；如果不成功，<整数或实数变量名>会变为0，<整数变量名>会变为不合法的字符的次序。（直接说那个不合法的字符位置就好了嘛为什么要说次序。。）

```delphi
//程序4_2_7_val
var a, b :longint;
begin
	val('123', a, b);
	writeln(a, '', b);
	//输出的是：123 0
	val('123qwertyuiop', a, b);
	writeln(a, '', b);
	//输出的是：04
end.
```

不需要去刻意地背阿

用的时候会用就行啦～

---------

gl & hf;

开始新的OI征程吧～

