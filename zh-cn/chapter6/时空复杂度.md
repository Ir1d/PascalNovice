#时空复杂度

注：本节中并没有形式化的严谨证明，请移步算导

一个算法是否优秀的一个重要因素是它所需要的时间。在这里我们给时间复杂度一个初步的定义：
例如，设待解决问题的规模为N，如果这种算法运行的时间与N大致成正比，则我们说这种算法的复杂度是O(N)的；如果它与$$N^2$$大致成正比，则是O(N^2)的；如果它与NlogN大致成正比，则是O(NlogN)的；等等。注意log的底数并不重要，因为根据换底公式它们是成正比的。不过如果没有特别说明，我们通常认为它的底数是2。
空间复杂度可以用同样的方式定义。
在通常的测评环境当中，评测机可以在1秒内进行约2亿次运算，据此可以大致得出复杂度——数据规模的换算表：


| 复杂度  |大致数据规模|
| --------   | :-----:  | 
|O(N)|$$10^8$$|
|O(NlogN)|$$10^6$$|
|O(Nlog^2N)|$$10^5$$|
|O(N^2)|$$10^4$$|
|O(N^3)|$$300$$|
|O(2^N)|$$25$$|
|O(N!)|$$11$$|

同理，在通常给定的128M空间中，大致能够存储这些复杂度的数：

| 复杂度  |大致数据量|
| --------   | :-----:  | 
|O(N)|$$10^7$$|
|O(NlogN)|$$510^5$$|
|O(Nlog^2N)|$$5*10^5$$|
|O(N^2)|$$5000$$|
|O(N^3)|$$250$$|
|O(2^N)|$$24$$|
|O(N!)|$$10$$|

根据不同的代码，我们可以快速判断出某些算法的复杂度。
如果代码只有循环的结构，我们可以很快判断出它的复杂度，例如找N个数中的最小值的复杂度是O(N)。
如果代码具有递归的结构，分析其复杂度就不一定容易。但或许会有一些方法，比如之前的“滑雪”程序经过优化以后，复杂度是O(RC)，因为每个f(i, j)被至多算过一遍。
接下来我们以排序算法为例，分析算法的复杂度。如无特殊说明，都是指从小到大排序。

-----------

gl & hf;

开始新的OI征程吧～
